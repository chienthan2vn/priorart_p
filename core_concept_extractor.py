"""
Core Concept Seed Keyword Extraction System
H·ªá th·ªëng tr√≠ch xu·∫•t t·ª´ kh√≥a g·ªëc s√°ng ch·∫ø v·ªõi 3 pha
"""

from typing import Dict, List, TypedDict, Annotated, Optional
from langchain_community.llms import Ollama
from langchain.prompts import PromptTemplate
from langchain.agents import create_react_agent, AgentExecutor
from langchain.tools import Tool
from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolNode
from langgraph.checkpoint.memory import MemorySaver
from pydantic import BaseModel, Field
import json


# Data Models
class ConceptMatrix(BaseModel):
    """Ma tr·∫≠n kh√°i ni·ªám cho Pha 1"""
    problem_purpose: str = Field(description="V·∫•n ƒë·ªÅ / m·ª•c ti√™u")
    object_system: str = Field(description="ƒê·ªëi t∆∞·ª£ng / h·ªá th·ªëng")
    action_method: str = Field(description="H√†nh ƒë·ªông / ph∆∞∆°ng ph√°p")
    key_technical_feature: str = Field(description="ƒê·∫∑c ƒëi·ªÉm k·ªπ thu·∫≠t c·ªët l√µi")
    environment_field: str = Field(description="M√¥i tr∆∞·ªùng / lƒ©nh v·ª±c ·ª©ng d·ª•ng")
    advantage_result: str = Field(description="L·ª£i √≠ch / k·∫øt qu·∫£ ƒë·∫°t ƒë∆∞·ª£c")


class SeedKeywords(BaseModel):
    """T·ª´ kh√≥a g·ªëc cho Pha 2"""
    problem_purpose: List[str] = Field(description="T·ª´ kh√≥a cho v·∫•n ƒë·ªÅ/m·ª•c ti√™u")
    object_system: List[str] = Field(description="T·ª´ kh√≥a cho ƒë·ªëi t∆∞·ª£ng/h·ªá th·ªëng")
    action_method: List[str] = Field(description="T·ª´ kh√≥a cho h√†nh ƒë·ªông/ph∆∞∆°ng ph√°p")
    key_technical_feature: List[str] = Field(description="T·ª´ kh√≥a cho ƒë·∫∑c ƒëi·ªÉm k·ªπ thu·∫≠t")
    environment_field: List[str] = Field(description="T·ª´ kh√≥a cho m√¥i tr∆∞·ªùng/lƒ©nh v·ª±c")
    advantage_result: List[str] = Field(description="T·ª´ kh√≥a cho l·ª£i √≠ch/k·∫øt qu·∫£")


class ValidationFeedback(BaseModel):
    """Ph·∫£n h·ªìi ƒë√°nh gi√° t·ª´ ng∆∞·ªùi d√πng"""
    is_approved: bool
    feedback: Optional[str] = None
    suggestions: Optional[List[str]] = None


class ExtractionState(TypedDict):
    """State cho LangGraph workflow"""
    input_text: str
    concept_matrix: Optional[ConceptMatrix]
    seed_keywords: Optional[SeedKeywords]
    validation_feedback: Optional[ValidationFeedback]
    final_keywords: Optional[SeedKeywords]
    current_phase: str
    messages: List[str]


class CoreConceptExtractor:
    """H·ªá th·ªëng tr√≠ch xu·∫•t t·ª´ kh√≥a g·ªëc s√°ng ch·∫ø"""
    
    def __init__(self, model_name: str = "llama3"):
        self.llm = Ollama(model=model_name, temperature=0.3)
        self.graph = self._build_graph()
    
    def _build_graph(self) -> StateGraph:
        """X√¢y d·ª±ng LangGraph workflow"""
        workflow = StateGraph(ExtractionState)
        
        # Th√™m c√°c nodes
        workflow.add_node("phase1_concept_extraction", self.phase1_concept_extraction)
        workflow.add_node("phase2_keyword_extraction", self.phase2_keyword_extraction)
        workflow.add_node("human_validation", self.human_validation)
        workflow.add_node("phase3_refinement", self.phase3_refinement)
        workflow.add_node("finalize", self.finalize_results)
        
        # ƒê·ªãnh nghƒ©a lu·ªìng
        workflow.set_entry_point("phase1_concept_extraction")
        workflow.add_edge("phase1_concept_extraction", "phase2_keyword_extraction")
        workflow.add_edge("phase2_keyword_extraction", "human_validation")
        workflow.add_conditional_edges(
            "human_validation",
            self._should_refine,
            {
                "refine": "phase3_refinement",
                "approve": "finalize"
            }
        )
        workflow.add_edge("phase3_refinement", "human_validation")
        workflow.add_edge("finalize", END)
        
        return workflow.compile(checkpointer=MemorySaver())
    
    def phase1_concept_extraction(self, state: ExtractionState) -> ExtractionState:
        """Pha 1: Tr·ª´u t∆∞·ª£ng h√≥a & ƒê·ªãnh nghƒ©a Kh√°i ni·ªám"""
        prompt = PromptTemplate.from_template("""
        Ph√¢n t√≠ch t√†i li·ªáu k·ªπ thu·∫≠t sau v√† tr√≠ch xu·∫•t th√¥ng tin cho Ma tr·∫≠n Kh√°i ni·ªám:

        T√†i li·ªáu: {input_text}

        H√£y ƒëi·ªÅn th√¥ng tin s√∫c t√≠ch cho t·ª´ng th√†nh ph·∫ßn (1-2 c√¢u ng·∫Øn):

        1. Problem/Purpose (V·∫•n ƒë·ªÅ/m·ª•c ti√™u):
        2. Object/System (ƒê·ªëi t∆∞·ª£ng/h·ªá th·ªëng):
        3. Action/Method (H√†nh ƒë·ªông/ph∆∞∆°ng ph√°p):
        4. Key Technical Feature/Structure (ƒê·∫∑c ƒëi·ªÉm k·ªπ thu·∫≠t c·ªët l√µi):
        5. Environment/Field (M√¥i tr∆∞·ªùng/lƒ©nh v·ª±c ·ª©ng d·ª•ng):
        6. Advantage/Result (L·ª£i √≠ch/k·∫øt qu·∫£ ƒë·∫°t ƒë∆∞·ª£c):

        Tr·∫£ v·ªÅ ƒë·ªãnh d·∫°ng JSON v·ªõi c√°c key: problem_purpose, object_system, action_method, key_technical_feature, environment_field, advantage_result
        """)
        
        response = self.llm.invoke(prompt.format(input_text=state["input_text"]))
        
        try:
            # Parse JSON response
            concept_data = json.loads(response.strip())
            concept_matrix = ConceptMatrix(**concept_data)
        except:
            # Fallback parsing n·∫øu JSON kh√¥ng h·ª£p l·ªá
            concept_matrix = self._parse_concept_response(response)
        
        state["concept_matrix"] = concept_matrix
        state["current_phase"] = "phase1_completed"
        state["messages"].append(f"Pha 1 ho√†n th√†nh: ƒê√£ tr√≠ch xu·∫•t Ma tr·∫≠n Kh√°i ni·ªám")
        
        return state
    
    def phase2_keyword_extraction(self, state: ExtractionState) -> ExtractionState:
        """Pha 2: Tr√≠ch xu·∫•t T·ª´ kh√≥a G·ªëc"""
        concept_matrix = state["concept_matrix"]
        
        prompt = PromptTemplate.from_template("""
        T·ª´ Ma tr·∫≠n Kh√°i ni·ªám sau, tr√≠ch xu·∫•t 1-3 t·ª´ kh√≥a/c·ª•m t·ª´ k·ªπ thu·∫≠t ƒë·∫∑c tr∆∞ng cho m·ªói th√†nh ph·∫ßn.
        ∆Øu ti√™n danh t·ª´ k·ªπ thu·∫≠t v√† ƒë·ªông t·ª´ ch√≠nh, tr√°nh t·ª´ qu√° chung.

        Ma tr·∫≠n Kh√°i ni·ªám:
        - Problem/Purpose: {problem_purpose}
        - Object/System: {object_system}
        - Action/Method: {action_method}
        - Key Technical Feature: {key_technical_feature}
        - Environment/Field: {environment_field}
        - Advantage/Result: {advantage_result}

        Tr·∫£ v·ªÅ ƒë·ªãnh d·∫°ng JSON v·ªõi m·ªói th√†nh ph·∫ßn l√† m·ªôt m·∫£ng t·ª´ kh√≥a:
        {{
            "problem_purpose": ["keyword1", "keyword2"],
            "object_system": ["keyword1"],
            ...
        }}
        """)
        
        response = self.llm.invoke(prompt.format(**concept_matrix.dict()))
        
        try:
            keyword_data = json.loads(response.strip())
            seed_keywords = SeedKeywords(**keyword_data)
        except:
            seed_keywords = self._parse_keyword_response(response)
        
        state["seed_keywords"] = seed_keywords
        state["current_phase"] = "phase2_completed"
        state["messages"].append(f"Pha 2 ho√†n th√†nh: ƒê√£ tr√≠ch xu·∫•t t·ª´ kh√≥a g·ªëc")
        
        return state
    
    def human_validation(self, state: ExtractionState) -> ExtractionState:
        """Human-in-the-loop validation"""
        print("\n" + "="*60)
        print("üîç ƒê√ÅNH GI√Å K·∫æT QU·∫¢ TR√çCH XU·∫§T T·ª™ KH√ìA")
        print("="*60)
        
        # Hi·ªÉn th·ªã k·∫øt qu·∫£
        concept_matrix = state["concept_matrix"]
        seed_keywords = state["seed_keywords"]
        
        print("\nüìã Ma tr·∫≠n Kh√°i ni·ªám:")
        for field, value in concept_matrix.dict().items():
            print(f"  ‚Ä¢ {field.replace('_', ' ').title()}: {value}")
        
        print("\nüîë T·ª´ kh√≥a g·ªëc:")
        for field, keywords in seed_keywords.dict().items():
            print(f"  ‚Ä¢ {field.replace('_', ' ').title()}: {keywords}")
        
        print("\n" + "-"*60)
        
        # L·∫•y ph·∫£n h·ªìi t·ª´ ng∆∞·ªùi d√πng
        while True:
            approval = input("B·∫°n c√≥ h√†i l√≤ng v·ªõi k·∫øt qu·∫£? (y/n): ").lower().strip()
            if approval in ['y', 'yes', 'c√≥']:
                feedback = ValidationFeedback(is_approved=True)
                break
            elif approval in ['n', 'no', 'kh√¥ng']:
                feedback_text = input("Nh·∫≠n x√©t c·ªßa b·∫°n: ")
                suggestions = input("ƒê·ªÅ xu·∫•t c·∫£i thi·ªán (c√°ch nhau b·ªüi d·∫•u ;): ")
                
                feedback = ValidationFeedback(
                    is_approved=False,
                    feedback=feedback_text,
                    suggestions=suggestions.split(';') if suggestions else None
                )
                break
            else:
                print("Vui l√≤ng nh·∫≠p 'y' ho·∫∑c 'n'")
        
        state["validation_feedback"] = feedback
        state["messages"].append(f"ƒê√°nh gi√° ng∆∞·ªùi d√πng: {'Ch·∫•p thu·∫≠n' if feedback.is_approved else 'Y√™u c·∫ßu c·∫£i thi·ªán'}")
        
        return state
    
    def phase3_refinement(self, state: ExtractionState) -> ExtractionState:
        """Pha 3: Ki·ªÉm tra & Tinh ch·ªânh"""
        feedback = state["validation_feedback"]
        current_keywords = state["seed_keywords"]
        
        prompt = PromptTemplate.from_template("""
        C·∫£i thi·ªán t·ª´ kh√≥a g·ªëc d·ª±a tr√™n ph·∫£n h·ªìi c·ªßa ng∆∞·ªùi d√πng:

        T·ª´ kh√≥a hi·ªán t·∫°i:
        {current_keywords}

        Ph·∫£n h·ªìi ng∆∞·ªùi d√πng: {feedback}
        ƒê·ªÅ xu·∫•t: {suggestions}

        H√£y tinh ch·ªânh t·ª´ kh√≥a ƒë·ªÉ:
        1. ƒê·∫£m b·∫£o ƒë·ªß ƒë·∫∑c tr∆∞ng, tr√°nh qu√° chung
        2. B·ªï sung kh√°i ni·ªám k·ªπ thu·∫≠t quan tr·ªçng b·ªã thi·∫øu
        3. T·ªëi ∆∞u h√≥a cho t√¨m ki·∫øm s√°ng ch·∫ø

        Tr·∫£ v·ªÅ ƒë·ªãnh d·∫°ng JSON t∆∞∆°ng t·ª± nh∆∞ tr∆∞·ªõc.
        """)
        
        response = self.llm.invoke(prompt.format(
            current_keywords=current_keywords.dict(),
            feedback=feedback.feedback or "",
            suggestions="; ".join(feedback.suggestions) if feedback.suggestions else ""
        ))
        
        try:
            refined_data = json.loads(response.strip())
            refined_keywords = SeedKeywords(**refined_data)
        except:
            refined_keywords = self._parse_keyword_response(response)
        
        state["seed_keywords"] = refined_keywords
        state["current_phase"] = "phase3_completed"
        state["messages"].append(f"Pha 3 ho√†n th√†nh: ƒê√£ tinh ch·ªânh t·ª´ kh√≥a")
        
        return state
    
    def finalize_results(self, state: ExtractionState) -> ExtractionState:
        """Ho√†n thi·ªán k·∫øt qu·∫£ cu·ªëi c√πng"""
        state["final_keywords"] = state["seed_keywords"]
        state["current_phase"] = "completed"
        state["messages"].append("‚úÖ Ho√†n th√†nh tr√≠ch xu·∫•t t·ª´ kh√≥a g·ªëc s√°ng ch·∫ø")
        
        return state
    
    def _should_refine(self, state: ExtractionState) -> str:
        """ƒêi·ªÅu ki·ªán ƒë·ªÉ quy·∫øt ƒë·ªãnh c√≥ c·∫ßn tinh ch·ªânh kh√¥ng"""
        feedback = state["validation_feedback"]
        return "approve" if feedback.is_approved else "refine"
    
    def _parse_concept_response(self, response: str) -> ConceptMatrix:
        """Parse response khi JSON parsing th·∫•t b·∫°i"""
        lines = response.strip().split('\n')
        data = {}
        
        for line in lines:
            if ':' in line:
                key, value = line.split(':', 1)
                key = key.strip().lower().replace(' ', '_').replace('/', '_')
                if 'problem' in key or 'purpose' in key:
                    data['problem_purpose'] = value.strip()
                elif 'object' in key or 'system' in key:
                    data['object_system'] = value.strip()
                elif 'action' in key or 'method' in key:
                    data['action_method'] = value.strip()
                elif 'technical' in key or 'feature' in key:
                    data['key_technical_feature'] = value.strip()
                elif 'environment' in key or 'field' in key:
                    data['environment_field'] = value.strip()
                elif 'advantage' in key or 'result' in key:
                    data['advantage_result'] = value.strip()
        
        return ConceptMatrix(**data)
    
    def _parse_keyword_response(self, response: str) -> SeedKeywords:
        """Parse keyword response khi JSON parsing th·∫•t b·∫°i"""
        # Fallback parsing logic
        return SeedKeywords(
            problem_purpose=["extracted_keyword"],
            object_system=["extracted_keyword"],
            action_method=["extracted_keyword"],
            key_technical_feature=["extracted_keyword"],
            environment_field=["extracted_keyword"],
            advantage_result=["extracted_keyword"]
        )
    
    def extract_keywords(self, input_text: str) -> Dict:
        """Ch·∫°y quy tr√¨nh tr√≠ch xu·∫•t t·ª´ kh√≥a ho√†n ch·ªânh"""
        initial_state = ExtractionState(
            input_text=input_text,
            concept_matrix=None,
            seed_keywords=None,
            validation_feedback=None,
            final_keywords=None,
            current_phase="initialized",
            messages=[]
        )
        
        # Ch·∫°y workflow
        result = self.graph.invoke(initial_state)
        
        return {
            "final_keywords": result["final_keywords"].dict() if result["final_keywords"] else None,
            "concept_matrix": result["concept_matrix"].dict() if result["concept_matrix"] else None,
            "messages": result["messages"]
        }


if __name__ == "__main__":
    # Example usage
    extractor = CoreConceptExtractor(model_name="llama3")
    
    sample_text = """
    H·ªá th·ªëng t∆∞·ªõi ti√™u th√¥ng minh s·ª≠ d·ª•ng c·∫£m bi·∫øn ƒë·ªô ·∫©m ƒë·∫•t v√† d·ªØ li·ªáu th·ªùi ti·∫øt 
    ƒë·ªÉ t·ª± ƒë·ªông ƒëi·ªÅu khi·ªÉn l·ªãch t∆∞·ªõi n∆∞·ªõc. H·ªá th·ªëng gi√∫p ti·∫øt ki·ªám n∆∞·ªõc v√† t·ªëi ∆∞u 
    h√≥a vi·ªác chƒÉm s√≥c c√¢y tr·ªìng trong n√¥ng nghi·ªáp v√† l√†m v∆∞·ªùn.
    """
    
    print("üöÄ B·∫Øt ƒë·∫ßu tr√≠ch xu·∫•t t·ª´ kh√≥a g·ªëc s√°ng ch·∫ø...")
    results = extractor.extract_keywords(sample_text)
    
    print("\n" + "="*60)
    print("üìä K·∫æT QU·∫¢ CU·ªêI C√ôNG")
    print("="*60)
    print(json.dumps(results, indent=2, ensure_ascii=False))
